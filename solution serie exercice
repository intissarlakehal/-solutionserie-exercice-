intissar LkðŸ©·, [05/01/2025 11:13]
Exo6
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
Â Â Â  int data;
Â Â Â  struct Node* next;
} Node;

Node* reverse(Node* head) {
Â Â Â  Node* prev = NULL;
Â Â Â  Node* current = head;
Â Â Â  Node* next = NULL;
Â Â Â  while (current) {
Â Â Â Â Â Â Â  next = current->next;
Â Â Â Â Â Â Â  current->next = prev;
Â Â Â Â Â Â Â  prev = current;
Â Â Â Â Â Â Â  current = next;
Â Â Â  }
Â Â Â  return prev;
}

Node* createNode(int data) {
Â Â Â  Node* newNode = (Node*)malloc(sizeof(Node));
Â Â Â  newNode->data = data;
Â Â Â  newNode->next = NULL;
Â Â Â  return newNode;
}

void printList(Node* head) {
Â Â Â  while (head) {
Â Â Â Â Â Â Â  printf("%d -> ", head->data);
Â Â Â Â Â Â Â  head = head->next;
Â Â Â  }
Â Â Â  printf("NULL\n");
}

int main() {
Â Â Â  Node* head = createNode(1);
Â Â Â  head->next = createNode(2);
Â Â Â  head->next->next = createNode(3);
Â Â Â  head->next->next->next = createNode(4);

Â Â Â  printf("Original List:\n");
Â Â Â  printList(head);

Â Â Â  head = reverse(head);

Â Â Â  printf("Reversed List:\n");
Â Â Â  printList(head);

Â Â Â  return 0;
}

Exo7
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
Â Â Â  int data;
Â Â Â  struct Node* next;
} Node;

Node* merge(Node* left, Node* right) {
Â Â Â  if (!left) return right;
Â Â Â  if (!right) return left;
Â Â Â  if (left->data <= right->data) {
Â Â Â Â Â Â Â  left->next = merge(left->next, right);
Â Â Â Â Â Â Â  return left;
Â Â Â  } else {
Â Â Â Â Â Â Â  right->next = merge(left, right->next);
Â Â Â Â Â Â Â  return right;
Â Â Â  }
}

void split(Node* source, NodeÂ front, NodeÂ back) {
Â Â Â  Node* slow = source;
Â Â Â  Node* fast = source->next;
Â Â Â  while (fast) {
Â Â Â Â Â Â Â  fast = fast->next;
Â Â Â Â Â Â Â  if (fast) {
Â Â Â Â Â Â Â Â Â Â Â  slow = slow->next;
Â Â Â Â Â Â Â Â Â Â Â  fast = fast->next;
Â Â Â Â Â Â Â  }
Â Â Â  }
Â Â Â  *front = source;
Â Â Â  *back = slow->next;
Â Â Â  slow->next = NULL;
}

void sort(Node** headRef) {
Â Â Â  if (!*headRef || !(*headRef)->next) return;
Â Â Â  Node* head = *headRef;
Â Â Â  Node* left = NULL;
Â Â Â  Node* right = NULL;
Â Â Â  split(head, &left, &right);
Â Â Â  sort(&left);
Â Â Â  sort(&right);
Â Â Â  *headRef = merge(left, right);
}

Node* createNode(int data) {
Â Â Â  Node* newNode = (Node*)malloc(sizeof(Node));
Â Â Â  newNode->data = data;
Â Â Â  newNode->next = NULL;
Â Â Â  return newNode;
}

void printList(Node* head) {
Â Â Â  while (head) {
Â Â Â Â Â Â Â  printf("%d -> ", head->data);
Â Â Â Â Â Â Â  head = head->next;
Â Â Â  }
Â Â Â  printf("NULL\n");
}

int main() {
Â Â Â  Node* head = createNode(4);
Â Â Â  head->next = createNode(2);
Â Â Â  head->next->next = createNode(1);
Â Â Â  head->next->next->next = createNode(3);

Â Â Â  printf("Original List:\n");
Â Â Â  printList(head);

Â Â Â  sort(&head);

Â Â Â  printf("Sorted List:\n");
Â Â Â  printList(head);

Â Â Â  return 0;
}

Exo8
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
Â Â Â  int data;
Â Â Â  struct Node* next;
} Node;

Node* merge(Node* L1, Node* L2) {
Â Â Â  if (!L1) return L2;
Â Â Â  if (!L2) return L1;
Â Â Â  if (L1->data <= L2->data) {
Â Â Â Â Â Â Â  L1->next = merge(L1->next, L2);
Â Â Â Â Â Â Â  return L1;
Â Â Â  } else {
Â Â Â Â Â Â Â  L2->next = merge(L1, L2->next);
Â Â Â Â Â Â Â  return L2;
Â Â Â  }
}

Node* createNode(int data) {
Â Â Â  Node* newNode = (Node*)malloc(sizeof(Node));
Â Â Â  newNode->data = data;
Â Â Â  newNode->next = NULL;
Â Â Â  return newNode;
}

void printList(Node* head) {
Â Â Â  while (head) {
Â Â Â Â Â Â Â  printf("%d -> ", head->data);
Â Â Â Â Â Â Â  head = head->next;
Â Â Â  }
Â Â Â  printf("NULL\n");
}

int main() {
Â Â Â  Node* L1 = createNode(1);
Â Â Â  L1->next = createNode(3);
Â Â Â  L1->next->next = createNode(5);

Â Â Â  Node* L2 = createNode(2);
Â Â Â  L2->next = createNode(4);
Â Â Â  L2->next->next = createNode(6);

Â Â Â  printf("List 1:\n");
Â Â Â  printList(L1);

Â Â Â  printf("List 2:\n");
Â Â Â  printList(L2);

Â Â Â  Node* mergedList = merge(L1, L2);

Â Â Â  printf("Merged List:\n");
Â Â Â  printList(mergedList);

Â Â Â  return 0;
}

Exo9
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
Â Â Â  int data;
Â Â Â  struct Node* next;
} Node;

void remove_duplicates(Node* head) {

Â Â Â  Node* current = head;

intissar LkðŸ©·, [05/01/2025 11:13]
Â Â Â  Node* temp;
Â Â Â  while (current && current->next) {
Â Â Â Â Â Â Â  if (current->data == current->next->data) {
Â Â Â Â Â Â Â Â Â Â Â  temp = current->next;
Â Â Â Â Â Â Â Â Â Â Â  current->next = current->next->next;
Â Â Â Â Â Â Â Â Â Â Â  free(temp);
Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â  current = current->next;
Â Â Â Â Â Â Â  }
Â Â Â  }
}

Node* createNode(int data) {
Â Â Â  Node* newNode = (Node*)malloc(sizeof(Node));
Â Â Â  newNode->data = data;
Â Â Â  newNode->next = NULL;
Â Â Â  return newNode;
}

void printList(Node* head) {
Â Â Â  while (head) {
Â Â Â Â Â Â Â  printf("%d -> ", head->data);
Â Â Â Â Â Â Â  head = head->next;
Â Â Â  }
Â Â Â  printf("NULL\n");
}

int main() {
Â Â Â  Node* head = createNode(1);
Â Â Â  head->next = createNode(2);
Â Â Â  head->next->next = createNode(2);
Â Â Â  head->next->next->next = createNode(3);
Â Â Â  head->next->next->next->next = createNode(3);

Â Â Â  printf("Original List:\n");
Â Â Â  printList(head);

Â Â Â  remove_duplicates(head);

Â Â Â  printf("List After Removing Duplicates:\n");
Â Â Â  printList(head);

Â Â Â  return 0;
}

Exo10
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
Â Â Â  int data;
Â Â Â  struct Node* next;
} Node;

int findKthLargest(Node* head, int k) {
Â Â Â  Node* current;
Â Â Â  int max;
Â Â Â  for (int i = 0; i < k; i++) {
Â Â Â Â Â Â Â  current = head;
Â Â Â Â Â Â Â  max = -2147483648;
Â Â Â Â Â Â Â  Node* maxNode = NULL;
Â Â Â Â Â Â Â  while (current) {
Â Â Â Â Â Â Â Â Â Â Â  if (current->data > max) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  max = current->data;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  maxNode = current;
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  current = current->next;
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  if (maxNode) maxNode->data = -2147483648;
Â Â Â  }
Â Â Â  return max;
}

Node* createNode(int data) {
Â Â Â  Node* newNode = (Node*)malloc(sizeof(Node));
Â Â Â  newNode->data = data;
Â Â Â  newNode->next = NULL;
Â Â Â  return newNode;
}

void printList(Node* head) {
Â Â Â  while (head) {
Â Â Â Â Â Â Â  printf("%d -> ", head->data);
Â Â Â Â Â Â Â  head = head->next;
Â Â Â  }
Â Â Â  printf("NULL\n");
}

int main() {
Â Â Â  Node* head = createNode(3);
Â Â Â  head->next = createNode(1);
Â Â Â  head->next->next = createNode(4);
Â Â Â  head->next->next->next = createNode(1);
Â Â Â  head->next->next->next->next = createNode(5);

Â Â Â  printf("Original List:\n");
Â Â Â  printList(head);

Â Â Â  int k = 2;
Â Â Â  int result = findKthLargest(head, k);
Â Â Â  printf("The %d-th largest element is: %d\n", k, result);

Â Â Â  return 0;
}
